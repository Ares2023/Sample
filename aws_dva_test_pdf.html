<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>AWS Certified Developer - Associate (DVA-C02) 模擬試験</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            line-height: 1.6;
        }
        .breadcrumb {
            margin-bottom: 20px;
            font-size: 1em;
            color: #666;
        }
        .breadcrumb a {
            text-decoration: none;
            color: #007bff;
        }
        .breadcrumb a:hover {
            text-decoration: underline;
        }
        .breadcrumb span {
            font-weight: bold;
            color: #333;
        }
        .question {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 8px;
        }
        .summary {
            font-weight: bold;
            font-size: 1.2em;
            margin-top: 20px;
        }
        .explanation {
            padding-top: 10px;
            border-top: 1px dashed #eee;
            margin-top: 10px;
            font-size: 0.9em;
        }
        .question-header {
            margin-bottom: 10px;
        }
        .question-options label {
            display: block;
            margin-bottom: 5px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        .question-options input[type="radio"],
        .question-options input[type="checkbox"] {
            margin-right: 10px;
        }
        label.correct-choice {
            background-color: #e0ffe0;
            border: 1px solid green;
        }
        label.incorrect-choice {
            background-color: #ffe0e0;
            border: 1px solid red;
        }
        button {
            padding: 10px 20px;
            margin-right: 10px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: 5px;
            margin-bottom: 15px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .toggle-explanation-btn {
            background-color: #6c757d;
            padding: 5px 12px;
            font-size: 0.8em;
            margin-top: 10px;
        }
        .toggle-explanation-btn:hover {
            background-color: #5a6268;
        }
        .result-pass {
            color: green;
        }
        .result-fail {
            color: red;
        }
        .correct-answer-text {
            color: green;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div class="breadcrumb">
        <a href="index.html">世良サイト</a> &gt; <span>AWS Certified Developer - Associate (DVA-C02) 模擬試験</span>
    </div>

    <h1>AWS Certified Developer - Associate (DVA-C02) 模擬試験</h1>
    <p></p>

    <div>
        <button onclick="grade()">採点する</button>
        <button onclick="showAllAnswers()">すべての解答と解説を表示</button>
        <button onclick="clearAllHighlights()">リセット</button>
    </div>

    <div id="quiz"></div>

    <button onclick="grade()">採点する</button>
    <button onclick="showAllAnswers()">すべての解答と解説を表示</button>
    <button onclick="clearAllHighlights()">リセット</button>

    <h2 id="score" class="summary"></h2>

    <script>
        const questions = [
            {
                q: "1) A company is migrating a legacy application to Amazon EC2 instances. The application uses a user name and password that are stored in the source code to connect to a MySQL database. The company will migrate the database to an Amazon RDS for MySQL DB instance. As part of the migration, the company needs to implement a secure way to store and automatically rotate the database credentials. Which solution will meet these requirements?",
                options: [
                    "A) Store the database credentials in environment variables in an Amazon Machine Image (AMI). Rotate the credentials by replacing the AMI.",
                    "B) Store the database credentials in AWS Systems Manager Parameter Store. Configure Parameter Store to automatically rotate the credentials.",
                    "C) Store the database credentials in environment variables on the EC2 instances. Rotate the credentials by relaunching the EC2 instances.",
                    "D) Store the database credentials in AWS Secrets Manager. Configure Secrets Manager to automatically rotate the credentials."
                ],
                correct: "D",
                explanation: "AWS Secrets Manager helps protect the credentials that are needed to access databases, applications, services, and other IT resources. With Secrets Manager, you can rotate, manage, and retrieve database credentials, API keys, and other secrets throughout their lifecycle. Secrets Manager offers secret rotation with built-in integration for Amazon RDS, Amazon Redshift, and Amazon DocumentDB."
            },
            {
                q: "2) A developer is creating a web application that must give users the ability to post comments and receive feedback in near real time. Which solutions will meet these requirements? (Select TWO.)",
                options: [
                    "A) Create an AWS AppSync schema and corresponding APIs. Use an Amazon DynamoDB table as the data store.",
                    "B) Create a WebSocket API in Amazon API Gateway. Use an AWS Lambda function as the backend. Use an Amazon DynamoDB table as the data store.",
                    "C) Create an AWS Elastic Beanstalk application that is backed by an Amazon RDS database. Configure the application to allow long-lived TCP/IP sockets.",
                    "D) Create a GraphQL endpoint in Amazon API Gateway. Use an Amazon DynamoDB table as the data store.",
                    "E) Establish WebSocket connections to Amazon CloudFront. Use an AWS Lambda function as the CloudFront distribution's origin. Use an Amazon Aurora DB cluster as the data store."
                ],
                correct: ["A", "B"],
                explanation: "AWS AppSync and WebSocket APIs in Amazon API Gateway are both suitable for building applications that require real-time updates. AppSync is a managed GraphQL service that simplifies real-time data access, while a WebSocket API enables two-way communication between clients and a backend, such as a Lambda function."
            },
            {
                q: "3) A developer is adding sign-up and sign-in functionality to an application. The application must make an API call to a custom analytics solution to log user sign-in events. Which combination of actions should the developer perform to meet these requirements? (Select TWO.)",
                options: [
                    "A) Use Amazon Cognito to provide the sign-up and sign-in functionality.",
                    "B) Use AWS Identity and Access Management (IAM) to provide the sign-up and sign-in functionality.",
                    "C) Configure an AWS Config rule to make the API call when a user is authenticated.",
                    "D) Invoke an Amazon API Gateway method to make the API call when a user is authenticated.",
                    "E) Invoke an AWS Lambda function to make the API call when a user is authenticated."
                ],
                correct: ["A", "E"],
                explanation: "Amazon Cognito is the correct service for handling user sign-up and sign-in. To perform a custom action like logging an event after a user authenticates, you can use a Lambda function triggered by an Amazon Cognito post-authentication trigger."
            },
            {
                q: "4) A company is using Amazon API Gateway for its REST APIs in an AWS account. A developer wants to allow only IAM users from another AWS account to access the APIs. Which combination of steps should the developer take to meet these requirements? (Select TWO.)",
                options: [
                    "A) Create an IAM permission policy. Attach the policy to each IAM user. Set the method authorization type for the APIs to AWS_IAM. Use Signature Version 4 to sign the API requests.",
                    "B) Create an Amazon Cognito user pool. Add each IAM user to the user pool. Set the method authorization type for the APIs to COGNITO_USER_POOLS. Authenticate by using the IAM credentials in Amazon Cognito. Add the ID token to the request headers.",
                    "C) Create an Amazon Cognito identity pool. Add each IAM user to the identity pool. Set the method authorization type for the APIs to COGNITO_USER_POOLS. Authenticate by using the IAM credentials in Amazon Cognito. Add the access token to the request headers.",
                    "D) Create a resource policy for the APIs to allow access for each IAM user only.",
                    "E) Create an Amazon Cognito authorizer for the APIs to allow access for each IAM user only. Set the method authorization type for the APIs to COGNITO_USER_POOLS."
                ],
                correct: ["A", "D"],
                explanation: "A resource policy can grant API access to users in another AWS account. This is a best practice for cross-account access control. The APIs must also be configured with the AWS_IAM authorization type, and requests must be signed with Signature Version 4."
            },
            {
                q: "5) A developer is building a new application that transforms text files to .pdf files. A separate application writes the text files to a source Amazon S3 bucket. The new application must read the files as they arrive in Amazon S3 and must convert the files to .pdf files by using an AWS Lambda function. The developer has written an IAM policy to allow access to Amazon S3 and Amazon CloudWatch Logs. What should the developer do to ensure that the Lambda function has the correct permissions?",
                options: [
                    "A) Create a Lambda execution role by using AWS Identity and Access Management (IAM). Attach the IAM policy to the role. Assign the Lambda execution role to the Lambda function.",
                    "B) Create a Lambda execution user by using AWS Identity and Access Management (IAM). Attach the IAM policy to the user. Assign the Lambda execution user to the Lambda function.",
                    "C) Create a Lambda execution role by using AWS Identity and Access Management (IAM). Attach the IAM policy to the role. Store the IAM role as an environment variable in the Lambda function.",
                    "D) Create a Lambda execution user by using AWS Identity and Access Management (IAM). Attach the IAM policy to the user. Store the IAM user credentials as environment variables in the Lambda function."
                ],
                correct: "A",
                explanation: "Lambda functions use an execution role to assume permissions. You must create an IAM role with the necessary permissions (e.g., access to S3 and CloudWatch Logs) and assign that role to the Lambda function."
            },
            {
                q: "6) A developer is working on an application that stores highly confidential data in a database. The developer must use AWS Key Management Service (AWS KMS) with envelope encryption to protect the data. How should the developer configure the data encryption to meet these requirements?",
                options: [
                    "A) Encrypt the data by using a KMS key. Store the encrypted data in the database.",
                    "B) Encrypt the data by using a generated data key. Store the encrypted data in the database.",
                    "C) Encrypt the data by using a generated data key. Store the encrypted data and the data key ID in the database.",
                    "D) Encrypt the data by using a generated data key. Store the encrypted data and the encrypted data key in the database."
                ],
                correct: "D",
                explanation: "Envelope encryption involves encrypting the plaintext data with a data key, and then encrypting the data key itself with a master key (KMS key). Both the encrypted data and the encrypted data key must be stored in the database. When you need to decrypt the data, you first use the KMS key to decrypt the data key, and then use the decrypted data key to decrypt the data."
            },
            {
                q: "7) A developer is adding Amazon ElastiCache for Memcached to a company's existing record storage application. The developer has decided to use lazy loading based on an analysis of common record handling patterns. Which pseudocode example will correctly implement lazy loading?",
                options: [
                    "A) record_value  db.query(\"UPDATE Records SET Details (1) WHERE ID == {0}\", record key, record value) cache.set (record key, record_value)",
                    "B) record_value  cache.get(record_key) if (record value == NULL) record_value  db.query(\"SELECT Details FROM Records WHERE ID == {0}\", record key) cache.set (record key, record value)",
                    "C) record_value cache.get (record_key) db.query(\"UPDATE Records SET Details = (1) WHERE ID == {0}\", record key, record_value)",
                    "D) record value  db.query(\"SELECT Details FROM Records WHERE $ID==\\{0\\}\", record key) if (record value ! NULL) cache.set (record key, record value)"
                ],
                correct: "B",
                explanation: "Lazy loading is a caching strategy where the application first checks the cache for the requested data. If the data is not found (cache miss), it retrieves the data from the database, stores it in the cache, and then returns it to the user. This approach ensures the cache is only populated when a record is requested."
            },
            {
                q: "8) A developer is building a web application that uses Amazon API Gateway. The developer wants to maintain different environments for development (dev) and production (prod) workloads. The API will be backed by an AWS Lambda function with two aliases: one for dev and one for prod. How can the developer maintain these environments with the LEAST amount of configuration?",
                options: [
                    "A) Create a REST API for each environment. Integrate the APIs with the corresponding dev and prod aliases of the Lambda function. Deploy the APIs to their respective stages. Access the APIs by using the stage URLs.",
                    "B) Create one REST API. Integrate the API with the Lambda function by using a stage variable in place of an alias. Deploy the API to two different stages: dev and prod. Create a stage variable in each stage with different aliases as the values. Access the API by using the different stage URLs.",
                    "C) Create one REST API. Integrate the API with the dev alias of the Lambda function. Deploy the API to the dev environment. Configure a canary release deployment for the prod environment where the canary will integrate with the Lambda prod alias.",
                    "D) Create one REST API. Integrate the API with the prod alias of the Lambda function. Deploy the API to the prod environment. Configure a canary release deployment for the dev environment where the canary will integrate with the Lambda dev alias."
                ],
                correct: "B",
                explanation: "Using a single REST API with multiple deployment stages and stage variables is the most efficient way to manage different environments. A stage variable can hold the name of the Lambda alias (e.g., 'dev' or 'prod'), allowing the same API configuration to point to different Lambda aliases depending on the stage."
            },
            {
                q: "9) A developer wants to track the performance of an application that runs on a fleet of Amazon EC2 instances. The developer wants to view and track statistics, such as the average request latency and the maximum request latency, across the fleet. The developer wants to receive immediate notification if the average response time exceeds a threshold. Which solution will meet these requirements?",
                options: [
                    "A) Configure a cron job on each EC2 instance to measure the response time and update a log file stored in an Amazon S3 bucket every minute. Use an Amazon S3 event notification to invoke an AWS Lambda function that reads the log file and writes new entries to an Amazon OpenSearch Service cluster. Visualize the results in OpenSearch Dashboards. Configure OpenSearch Service to send an alert to an Amazon Simple Notification Service (Amazon SNS) topic when the response time exceeds the threshold.",
                    "B) Configure the application to write the response times to the system log. Install and configure the Amazon Inspector agent on the EC2 instances to continually read the logs and send the response times to Amazon EventBridge (Amazon CloudWatch Events). View the metrics graphs in the EventBridge (CloudWatch Events) console. Configure an EventBridge (CloudWatch Events) custom rule to send an Amazon Simple Notification Service (Amazon SNS) notification when the average of the response time metric exceeds the threshold.",
                    "C) Configure the application to write the response times to a log file. Install and configure the Amazon CloudWatch agent on the EC2 instances to stream the application log to CloudWatch Logs. Create a metric filter of the response time from the log. View the metrics graphs in the CloudWatch console. Create a CloudWatch alarm to send an Amazon Simple Notification Service (Amazon SNS) notification when the average of the response time metric exceeds the threshold.",
                    "D) Install and configure AWS Systems Manager Agent (SSM Agent) on the EC2 instances to monitor the response time and send the response time to Amazon CloudWatch as a custom metric. View the metrics graphs in Amazon QuickSight. Create a CloudWatch alarm to send an Amazon Simple Notification Service (Amazon SNS) notification when the average of the response time metric exceeds the threshold."
                ],
                correct: "C",
                explanation: "This is a classic CloudWatch use case. The CloudWatch agent can collect logs from EC2 instances and send them to CloudWatch Logs. From there, a metric filter can extract the response time metric, which can then be used to create graphs and trigger a CloudWatch alarm that sends a notification to an SNS topic when the threshold is breached."
            },
            {
                q: "10) A developer is testing an application locally and has deployed the application to an AWS Lambda function. To avoid exceeding the deployment package size quota, the developer did not include the dependencies in the deployment file. When the developer tests the application remotely, the Lambda function does not run because of missing dependencies. Which solution will resolve this issue?",
                options: [
                    "A) Use the Lambda console editor to update the code and include the missing dependencies.",
                    "B) Create an additional .zip file that contains the missing dependencies. Include the zip file in the original Lambda deployment package.",
                    "C) Add references to the missing dependencies in the Lambda function's environment variables.",
                    "D) Create a layer that contains the missing dependencies. Attach the layer to the Lambda function."
                ],
                correct: "D",
                explanation: "AWS Lambda Layers are the correct solution for sharing code and dependencies between Lambda functions. A layer is a .zip file archive that contains libraries, a custom runtime, or other dependencies. This keeps the deployment package size small and allows multiple functions to use the same dependencies."
            }
        ];

        function grade() {
            let correctCount = 0;
            const totalQuestions = questions.length;
            questions.forEach((qData, index) => {
                const questionDiv = document.getElementById(`q-container-${index}`);
                const selectedInputs = Array.from(questionDiv.querySelectorAll(`input[name="q${index}"]:checked`));
                const selectedValues = selectedInputs.map(input => input.value);
                
                let isCorrect;
                const correctAnswers = Array.isArray(qData.correct) ? qData.correct : [qData.correct];

                if (Array.isArray(qData.correct)) {
                    isCorrect = (selectedValues.length === qData.correct.length) &&
                        selectedValues.sort().every((val, idx) => val === [...qData.correct].sort()[idx]);
                } else {
                    isCorrect = (selectedValues.length === 1 && selectedValues[0] === qData.correct);
                }

                if (isCorrect) {
                    correctCount++;
                }

                // Highlight user's selections and correct answers
                questionDiv.querySelectorAll('.question-options label').forEach(label => {
                    label.classList.remove('correct-choice', 'incorrect-choice');
                    const value = label.getAttribute('data-value');
                    if (selectedValues.includes(value)) {
                        if (correctAnswers.includes(value)) {
                            label.classList.add('correct-choice');
                        } else {
                            label.classList.add('incorrect-choice');
                        }
                    } else if (!isCorrect && correctAnswers.includes(value)) {
                        label.classList.add('correct-choice');
                    }
                });

                questionDiv.querySelector('.explanation').style.display = 'block';
            });
            
            const scoreEl = document.getElementById('score');
            const passMark = Math.ceil(totalQuestions * 0.65);
            scoreEl.innerHTML = `あなたのスコア: ${correctCount} / ${totalQuestions}問 正解`;
            if (correctCount >= passMark) {
                scoreEl.innerHTML += `<br><span class="result-pass">🎉 合格圏内です！おめでとうございます！</span>`;
            } else {
                scoreEl.innerHTML += `<br><span class="result-fail">📘 もう少し頑張りましょう！</span>`;
            }
        }

        function showAllAnswers() {
            questions.forEach((qData, index) => {
                const questionDiv = document.getElementById(`q-container-${index}`);
                questionDiv.querySelectorAll('.question-options label').forEach(label => {
                    label.classList.remove('correct-choice', 'incorrect-choice');
                });
                
                const correctAnswers = Array.isArray(qData.correct) ? qData.correct : [qData.correct];
                correctAnswers.forEach(correctValue => {
                    const label = questionDiv.querySelector(`label[data-value="${correctValue}"]`);
                    if (label) {
                        label.classList.add('correct-choice');
                    }
                });

                questionDiv.querySelector('.explanation').style.display = 'block';
            });
        }

        function clearAllHighlights() {
            document.querySelectorAll('.question-options label').forEach(label => {
                label.classList.remove('correct-choice', 'incorrect-choice');
            });
            document.querySelectorAll('.explanation').forEach(el => {
                el.style.display = 'none';
            });
            document.getElementById('score').innerHTML = '';
            document.querySelectorAll('input').forEach(input => input.checked = false);
        }

        function generateQuiz() {
            const quiz = document.getElementById('quiz');
            quiz.innerHTML = '';
            const totalQuestions = questions.length;
            document.querySelector('p').textContent = `全${totalQuestions}問`;

            questions.forEach((q, index) => {
                const div = document.createElement('div');
                div.className = 'question';
                div.id = `q-container-${index}`;

                const header = document.createElement('div');
                header.className = 'question-header';
                const questionText = q.q.replace(/^\d+\)\s*/, '');
                header.innerHTML = `<strong>問 ${index + 1}. ${questionText}</strong>`;
                div.appendChild(header);

                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'question-options';
                q.options.forEach((opt, i) => {
                    const label = document.createElement('label');
                    const input = document.createElement('input');
                    const value = String.fromCharCode(65 + i);
                    input.type = q.correct instanceof Array ? 'checkbox' : 'radio';
                    input.name = `q${index}`;
                    input.value = value;
                    label.appendChild(input);
                    label.appendChild(document.createTextNode(' ' + opt));
                    label.setAttribute('data-value', value);
                    optionsDiv.appendChild(label);
                });
                div.appendChild(optionsDiv);

                const expl = document.createElement('div');
                expl.className = 'explanation';
                const correctOptions = Array.isArray(q.correct) ? q.correct.join(', ') : q.correct;
                expl.innerHTML = `<strong>正解:</strong> <span class="correct-answer-text">${correctOptions}</span><br><strong>解答解説:</strong> ${q.explanation}`;
                expl.style.display = 'none';
                div.appendChild(expl);

                quiz.appendChild(div);
            });
        }

        generateQuiz();
    </script>
</body>
</html>
