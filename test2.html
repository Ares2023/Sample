<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>OCI Architect Associate 小テスト後半</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            line-height: 1.6;
        }

        .breadcrumb {
            margin-bottom: 20px;
            font-size: 1em;
            color: #666;
        }

        .breadcrumb a {
            text-decoration: none;
            color: #007bff;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        .breadcrumb span {
            font-weight: bold;
            color: #333;
        }

        .question {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 8px;
        }

        .summary {
            font-weight: bold;
            font-size: 1.2em;
            margin-top: 20px;
        }

        .explanation {
            display: none;
            padding-top: 10px;
            border-top: 1px dashed #eee;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .explanation.visible {
            display: block;
        }

        .question-header {
            margin-bottom: 10px;
        }

        .question-options label {
            display: block;
            margin-bottom: 5px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .question-options input[type="radio"],
        .question-options input[type="checkbox"] {
            margin-right: 10px;
        }

        /* --- 回答フィードバック用のスタイルを追加 --- */
        label.correct-choice {
            background-color: #e0ffe0;
            /* 正解の選択肢の背景を薄い緑に */
            border: 1px solid green;
        }

        label.incorrect-choice {
            background-color: #ffe0e0;
            /* 不正解の選択肢の背景を薄い赤に */
            border: 1px solid red;
        }

        button {
            padding: 10px 20px;
            margin-right: 10px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }

        .toggle-explanation-btn {
            background-color: #6c757d;
            padding: 5px 12px;
            font-size: 0.8em;
            margin-top: 10px;
        }

        .toggle-explanation-btn:hover {
            background-color: #5a6268;
        }

        .result-pass {
            color: green;
        }

        .result-fail {
            color: red;
        }
    </style>
</head>

<body>
    <div class="breadcrumb">
        <a href="index.html">世良サイト</a> > <span>OCI Architect Associate 小テスト後半</span>
    </div>

    <h1>OCI Architect Associate 小テスト後半</h1>
    <h3>※この問題は田中さんのGoogle Form問題を移植したものだよ。解説にAI生成を用いているので、正確性には注意してね。</h3>
    <p></p>

    <button onclick="shuffleAndRegenerate()">問題をシャッフル</button>
    <button onclick="grade()">採点する</button>
    <button onclick="showAllAnswers()">すべての解説を表示</button>
    <button onclick="clearAllHighlights()">ハイライトを消去</button>
    
      <h2 id="score" class="summary"></h2>
    
    <div id="quiz"></div>

    <button onclick="shuffleAndRegenerate()">問題をシャッフル</button>
    <button onclick="grade()">採点する</button>
    <button onclick="showAllAnswers()">すべての解説を表示</button>
    <button onclick="clearAllHighlights()">ハイライトを消去</button>

    <h2 id="score" class="summary"></h2>

    <script>
        const questions = [
            { q: "コンピュートのシェイプに関する説明として正しいものはどれか。3つ選択してください。", options: ["a) Fixedシェイプはサイズの変更ができない", "b) Fixedシェイプを使用できるのはBMだけである", "c) インスタンスに割り当てられたリソース(CPU/メモリ/ストレージ)を決定するテンプレートのこと", "d) Flexibleシェイプを使用できるのはVMだけである"], correct: ["a", "c", "d"], explanation: "正解: a), c), d)<br>シェイプは、インスタンスに割り当てられるCPU、メモリ、ネットワーク帯域幅などのリソースを定義するテンプレートです。<b>Fixed</b>シェイプはリソース量が固定で変更できません。<b>Flexible</b>シェイプはVMインスタンスでのみ利用可能で、CPUやメモリの量を柔軟に変更できます。FixedシェイプはBMだけでなく、一部のVMでも使用されます。" },
            { q: "コンピュートで選択できるタイプのうち正しい組み合わせはどれか。", options: ["a) ・物理的なサーバ(シングルテナントモデル)：Bare Metal(BM)　・仮想的なサーバ(マルチテナントモデル)：Virtual Machine(VM)　・物理的なサーバ内の仮想マシンすべてを占有(共有されないシングルテナントモデル)：Dedicated VM Hosts(DVH)", "b) ・物理的なサーバ(シングルテナントモデル)：Virtual Machine(VM)　・仮想的なサーバ(マルチテナントモデル)：Bare Metal(BM)　・物理的なサーバ内の仮想マシンすべてを占有(共有されないシングルテナントモデル)：Dedicated VM Hosts(DVH)", "c) ・物理的なサーバ(シングルテナントモデル)：Dedicated VM Hosts(DVH)　・仮想的なサーバ(マルチテナントモデル)：Bare Metal(BM)　・物理的なサーバ内の仮想マシンすべてを占有(共有されないシングルテナントモデル)：Virtual Machine(VM)", "d) ・物理的なサーバ(シングルテナントモデル)：Dedicated VM Hosts(DVH)　・仮想的なサーバ(マルチテナントモデル)：Virtual Machine(VM)　・物理的なサーバ内の仮想マシンすべてを占有(共有されないシングルテナントモデル)：Bare Metal(BM)"], correct: "a", explanation: "正解: a)<br><b>Bare Metal (BM)</b>: 物理サーバー全体を単一の顧客が占有するモデルです。<br><b>Virtual Machine (VM)</b>: 物理サーバー上のハイパーバイザーで実行される仮想サーバーで、通常は複数の顧客で物理リソースを共有します（マルチテナント）。<br><b>Dedicated VM Host (DVH)</b>: 物理サーバーを占有し、その上で自社専用のVMのみを実行できるシングルテナントモデルです。" },
            { q: "フレキシブル・シェイプでサイズを変更することができるのは次のうちどれか。2つ選択してください。", options: ["a) CPU(OCPU)", "b) ストレージ", "c) メモリ", "d) シェイプ"], correct: ["a", "c"], explanation: "正解: a), c)<br>フレキシブル・シェイプ（Flexible Shape）を持つVMインスタンスでは、<b>OCPU数</b>と<b>メモリ量</b>を、シェイプごとに定められた範囲内で柔軟に、インスタンスを停止することなく変更できます。ストレージはブロック・ボリュームとして別途管理・変更します。" },
            { q: "GPUシェイプを選択するメリットはどれか。", options: ["a) 処理速度が速く、仮想マシンの起動時間が短い", "b) 単純な計算など、決まった処理を行うことに優れている", "c) ストレージ容量が多く、大量のデータを保存できる", "d) 並列処理能力に優れている"], correct: "d", explanation: "正解: d) GPUシェイプの最大のメリットは、数千のコアによる<b>高い並列処理能力</b>です。これにより、AI/機械学習のトレーニング、科学技術計算（HPC）、3Dレンダリングなど、膨大な計算を同時に行う必要があるワークロードを高速化できます。" },
            { q: "コンピュートイメージに関する説明として正しいものはどれか。2つ選択してください。", options: ["a) コンピュートイメージはコンピュートにどのOSを設定するかを選択するもの", "b) コンピュートイメージはコンピュートにどのくらいのCPU数、メモリ数を設定するかを選択するもの", "c) コンピュートを作成する場合、イメージを選択せずに作成することもできる", "d) コンピュートを作成する場合、イメージを選択しないと作成ができない"], correct: ["a", "d"], explanation: "正解: a), d)<br>コンピュート・イメージは、インスタンスのルート・ディスク（ブート・ディスク）のテンプレートであり、OSやその他のソフトウェアが含まれます。インスタンスを作成する際には、必ず何らかのイメージを選択する必要があります。CPU数やメモリ数を決めるのは「シェイプ」です。" },
            { q: "コンピュートイメージとして使用ができる4つのイメージソースはどれか。", options: ["a) ・デフォルトイメージ　・カスタムイメージ　・マーケットプレイス　・独自イメージ", "b) ・Oracle提供イメージ　・カスタムイメージ　・マーケットプレイス　・独自イメージ", "c) ・デフォルトイメージ　・アイデンティティイメージ　・マーケットプレイス　・独自イメージ", "d) ・Oracle提供イメージ　・カスタムイメージ　・アプリケーションプレイス　・独自イメージ"], correct: "b", explanation: "正解: b)<br>OCIでは、<b>Oracle提供イメージ</b>（Oracle Linux, Windows等）、ユーザーが作成した<b>カスタムイメージ</b>、パートナー企業が提供する<b>マーケットプレイス</b>イメージ、そしてオンプレミス等から持ち込む<b>独自イメージ</b>（BYOI）の4種類をソースとしてインスタンスを作成できます。" },
            { q: "すでに作成してあるインスタンスからイメージを作成し、新しいインスタンスを作成する場合に使用するものはどれか。", options: ["a) Oracle提供イメージ", "b) カスタムイメージ", "c) マーケットプレイス", "d) 独自イメージ"], correct: "b", explanation: "正解: b) 既存のインスタンス（OSの設定やアプリケーションのインストール済み）の状態をテンプレートとして保存したものが<b>カスタムイメージ</b>です。これを使うことで、同じ構成のインスタンスを迅速に複製できます。" },
            { q: "既存オンプレミス環境のシステムで使用していたサーバイメージを、OCI環境でも使用したい場合、どのようにして実装するか。以下手順で正しい順序のものはどれか。\n１．OCI オブジェクトストレージにイメージをアップロードする　２．カスタムイメージを作成する　３．既存システムのサーバイメージをqcow2形式のイメージにする　４．カスタムイメージを使用してコンピュートを作成する", options: ["a) 1→2→3→4", "b) 2→1→3→4", "c) 2→1→4→3", "d) 3→1→2→4"], correct: "d", explanation: "正解: d) オンプレミスのイメージをOCIで利用する手順は以下の通りです。<br><b>3.</b> まず、オンプレミスのイメージをOCIがサポートする形式（qcow2, VMDKなど）に変換します。<br><b>1.</b> 次に、変換したイメージファイルをObject Storageにアップロードします。<br><b>2.</b> Object Storage上のファイルからカスタムイメージとしてインポートします。<br><b>4.</b> 最後に、作成したカスタムイメージからコンピュート・インスタンスを起動します。" },
            { q: "プリエンティブルインスタンスに関する説明として正しいものはどれか。2つ選択してください。", options: ["a) 短期利用向けのインスタンスであり、他インスタンスで容量が不足した場合、プリエンティブルインスタンスの容量が回収され使用ができなくなる。その代わり安価で利用ができる", "b) 設定した期間でのみ使用が可能となる。その代わり安価で利用ができる", "c) 使用ができなくなった場合、プリエンティブルインスタンスは削除される", "d) 使用ができなくなった場合でもプリエンティブルインスタンスは削除されないが、インスタンスへのログインができなくなる"], correct: ["a", "c"], explanation: "正解: a), c)<br>プリエンプティブル・インスタンスは、OCIの余剰キャパシティを非常に安価（オンデマンドの半額）で利用できるインスタンスです。ただし、キャパシティが必要になった場合、Oracleによっていつでも中断（プリエンプト）される可能性があります。中断されたインスタンスは<b>削除</b>されます。バッチ処理などの中断が許容される短期的なワークロードに適しています。" },
            { q: "プリエンティブルインスタンスに関する説明として正しいものはどれか。3つ選択してください。", options: ["a) プリエンティブルインスタンスは作成後にシェイプの変更ができない", "b) プリエンティブルインスタンスとして作成したインスタンスは、作成後に通常のインスタンスに切り替えることができない", "c) プリエンティブルインスタンスは作成後にシェイプの変更が可能である", "d) 通常のインスタンス(オンデマンドインスタンス)に比べて50%コストが削減できる"], correct: ["a", "b", "d"], explanation: "正解: a), b), d)<br>プリエンプティブル・インスタンスは、オンデマンド・インスタンスと比較して常に<b>50%割引</b>の価格で提供されます。一度作成すると、<b>シェイプの変更や通常のインスタンスへの変換はできません</b>。これらの制約と引き換えに、大幅なコスト削減を実現します。" },
            { q: "容量予約に関する説明として正しいものはどれか。2つ選択してください。", options: ["a) 予約したアベイラビリティドメイン以外のアベイラビリティドメインでも予約した容量を使用することができる", "b) 特定の可用性ドメインに関連付けられた予約のため、別のアベイラビリティドメインで予約した容量を使用することはできない", "c) 専用仮想マシンでの容量予約の使用はできない", "d) 予約した容量のサイズは予約後に変更ができない"], correct: ["b", "c"], explanation: "正解: b), c)<br>容量予約は、特定のシェイプのコンピュート・リソースを、<b>特定の可用性ドメイン（AD）内</b>で確保しておく機能です。予約した容量は他のADでは使用できません。また、予約のサイズ（インスタンス数）の変更は可能です。" },
            { q: "専用仮想マシン・ホストを利用するメリットはどれか。", options: ["a) 他のお客様とテナントを共有しない", "b) ストレージを無制限に使用できる", "c) 高速なネットワーク回線が使用できる", "d) ベアメタルも仮想マシンもどちらも使用することができる"], correct: "a", explanation: "正解: a) 専用仮想マシン・ホスト（Dedicated VM Host）の最大のメリットは、物理サーバーを完全に占有できる<b>シングルテナント環境</b>であることです。これにより、コンプライアンス要件やライセンス要件（BYOL）に対応しつつ、他のテナントからの性能影響（ノイジーネイバー問題）を排除できます。" },
            { q: "バースト可能インスタンスに関する説明として正しいものはどれか。2つ選択してください。", options: ["a) メモリはバーストすることができない", "b) 一時的に大量のストレージを使用することができる", "c) 一時的に高速なネットワークを使用することができる", "d) 一時的に高いCPUパフォーマンスを提供することができる"], correct: ["a", "d"], explanation: "正解: a), d)<br>バースト可能インスタンスは、通常はベースラインのCPU使用率で動作しますが、必要に応じて<b>一時的にCPUパフォーマンスをベースライン以上にバースト</b>させることができます。この機能はCPUに限定されており、メモリやネットワーク、ストレージはバーストの対象外です。" },
            { q: "バースト可能インスタンスにおいて、バースト可能のベースラインとして設定できる値はどれか。2つ選択してください。", options: ["a) 10%", "b) 12.5%", "c) 30%", "d) 50%"], correct: ["b", "d"], explanation: "正解: b), d)<br>バースト可能インスタンスのCPUベースラインは、OCPU全体の<b>12.5%</b>または<b>50%</b>のいずれかを選択できます。これにより、普段のCPU負荷が低いが、時折高いパフォーマンスが必要となるワークロードにコスト効率よく対応できます。" },
            { q: "インスタンス構成とインスタンスプールに関する説明として正しいものはどれか。3つ選択してください。", options: ["a) 1つのインスタンスプールに対し、複数のインスタンス構成を関連付けることができる", "b) インスタンス構成はインスタンスの定義ファイル(OSイメージ、メタデータ、シェイプ、VNIC、ストレージ、サブネット)である", "c) 1つのインスタンスプールに対し、1つのインスタンス構成を関連付けることができる", "d) インスタンスプールはプール内のインスタンスをインスタンス構成を元に複数インスタンス立ち上げなどのスケーリングを行うことができる"], correct: ["b", "c", "d"], explanation: "正解: b), c), d)<br><b>インスタンス構成</b>は、インスタンスを作成するための設定（イメージ、シェイプ、VCN/サブネット、メタデータ等）を保存したテンプレートです。<b>インスタンスプール</b>は、このインスタンス構成を基に、複数の同一構成のインスタンスをまとめて管理・スケーリング（作成・終了）するための機能です。1つのプールは<b>1つのインスタンス構成</b>に関連付けられます。" },
            { q: "自動スケーリングで設定できるものはどれか。2つ選択してください。", options: ["a) キャパシティベースの自動スケーリング", "b) モニタリングベースの自動スケーリング", "c) メトリックベースの自動スケーリング", "d) スケジュールベースの自動スケーリング"], correct: ["c", "d"], explanation: "正解: c), d)<br>インスタンスプールの自動スケーリングには2つのタイプがあります。<br>・<b>メトリックベース</b>: CPUやメモリ使用率などのパフォーマンス・メトリックを監視し、しきい値に基づいてインスタンス数を増減させます。<br>・<b>スケジュールベース</b>: 特定の日時や定期的なスケジュールに基づいてインスタンス数を増減させます。" },
            { q: "Oracleクラウドエージェントの管理対象プラグインはどれか。3つ選択してください。", options: ["a) 要塞", "b) OS管理サービス・エージェント", "c) 実行コマンド(Run Command)", "d) インスタンスプール"], correct: ["a", "b", "c"], explanation: "正解: a), b), c)<br>Oracle Cloud Agentは、インスタンスの管理機能を拡張するプラグインを実行します。主なプラグインには、OSのパッチ管理を行う<b>OS管理サービス・エージェント</b>、スクリプトをリモート実行する<b>実行コマンド</b>、セキュアなアクセスを提供する<b>要塞(Bastion)</b>などがあります。インスタンスプールはエージェントのプラグインではありません。" },
            { q: "OS管理サービスの主な機能として正しいものはどれか。", options: ["a) 仮想マシンのネットワークトラフィックをリアルタイムで監視する機能", "b) オペレーティングシステムのパッチ適用、更新、パッケージ管理を行う機能", "c) データベースの自動バックアップとリストアを行う機能", "d) クラウドストレージの暗号化とアクセス制御を管理する機能"], correct: "b", explanation: "正解: b) OS管理サービス（OSMS）は、コンピュート・インスタンスのOS（Oracle Linux, Windows等）に対して、<b>セキュリティパッチの適用、パッケージの更新、ソフトウェアソースの構成管理</b>などを自動化・一元化する機能です。" },
            { q: "OS管理サービスの対象となるオペレーティングシステムはどれか。2つ選択してください。", options: ["a) Oracle Linux", "b) Microsoft Windows", "c) CentOS", "d) Ubuntu"], correct: ["a", "b"], explanation: "正解: a), b)<br>OS管理サービスは、<b>Oracle Linux</b>および<b>Microsoft Windows</b>の各バージョンに対応しています。CentOSやUbuntuもサポートされていますが、選択肢の中ではこの2つが主要な対象です。" },
            { q: "Run Commandを使用する利点として正しいものはどれか。", options: ["a) インスタンスのスナップショットを自動で作成することができる", "b) 仮想マシンのCPUとメモリを自動でスケーリングすることができる", "c) インスタンス内でスクリプトを実行し、インスタンスをリモートで構成、管理およびトラブルシューティングを行うことができる", "d) インスタンスのOS管理を自動で行うことができる"], correct: "c", explanation: "正解: c) 実行コマンド（Run Command）は、インスタンスにログインすることなく、コンソールやAPIから<b>スクリプト（シェルスクリプトやPowerShellなど）をリモートで実行</b>できる機能です。これにより、構成の自動化や一括管理、トラブルシューティングが容易になります。" },
            { q: "Run Commandで実行されるスクリプトのデフォルトのファイル形式はどれか。", options: ["a) Windows：バッチファイル　Oracle Linux：bashシェルスクリプト", "b) Windows：bashシェルスクリプト　Oracle Linux：バッチファイル", "c) Windows：bashシェルスクリプト　Oracle Linux：テキストファイル", "d) Windows：Powershell　Oracle Linux：bashシェルスクリプト"], correct: "a", explanation: "正解: a)<br>実行コマンド（Run Command）でスクリプトを実行する場合、対象OSのデフォルトのインタプリタが使用されます。" },
            { q: "インスタンス・コンソール接続のユースケースとして正しいものはどれか。", options: ["a) ポリシー権限が不足しており、正常にアクセスができない", "b) インスタンスから発生した通信がファイアウォール機能でブロックされており、正常にアクセスができない", "c) インスタンスが正常に起動せず、ログインができない"], correct: "c", explanation: "正解: c) インスタンス・コンソール接続は、OSが正常に起動せずSSHやRDPでのログインができない場合など、<b>インスタンスのトラブルシューティング</b>に使用します。インポートしたイメージに問題がある、ブート構成が破損しているといった状況で、シリアルコンソール経由でインスタンスを操作するために利用されます。" },
            { q: "保護インスタンスに関する説明として正しいものはどれか。", options: ["a) 許可していない通信を測定し、ブロックする", "b) クロスサイトスクリプティングやDOS攻撃からインスタンスを防御する", "c) 保護インスタンスはすべてのイメージ及びシェイプに対応している", "d) OSブート時の脅威に対するセキュリティ強化、防御を行う"], correct: "d", explanation: "正解: d) 保護インスタンスは、セキュアブートやメジャードブートといった機能を利用して、<b>OSが起動するプロセス（ブートプロセス）の改ざんや脅威を検知・防御</b>します。これにより、ファームウェアレベルでの攻撃に対するセキュリティを強化します。" },
            { q: "機密コンピューティングに関する説明として正しいものはどれか。2つ選択してください。", options: ["a) 許可していない通信を測定し、ブロックする", "b) 使用中のデータを保護し、不正アクセスや不正変更を防止する", "c) 機密コンピューティングはすべてのイメージ及びシェイプに対応している", "d) 処理中など、リアルタイムでデータの暗号化を行うことができる"], correct: ["b", "d"], explanation: "正解: b), d)<br>機密コンピューティング（Confidential Computing）は、データが「使用中」（メモリ上で処理中）の状態でも、<b>ハードウェアレベルで暗号化</b>する技術です。これにより、ハイパーバイザー管理者を含む外部からの不正なアクセスや改ざんから、機密データを保護します。" },
            { q: "ライブ移行に関する説明として正しいものはどれか。", options: ["a) 別の物理ホストにVMインスタンスを最小限の中断で移行する", "b) 短時間の停止時間が発生し、再起動を行うことで別の物理ホストにVMインスタンスを移行する(利用者側で再起動のスケジュールを指定可能)", "c) 短時間の停止時間が発生し、再起動を行うことで別の物理ホストにVMインスタンスを移行する(利用者側で再起動のスケジュールを指定不可)", "d) インスタンスを終了し、別の物理ホストに再作成する"], correct: "a", explanation: "正解: a) <br><b>ライブマイグレーション（Live Migration）</b>とは、仮想マシン（VM）インスタンスをシャットダウンすることなく、物理ホスト間で移動（マイグレーション）する機能です。" },
            { q: "オブジェクトストレージの有効範囲として正しいものはどれか。", options: ["a) 特定のコンピュートに関連づくサービス", "b) VCNに関連づくサービス", "c) リージョンに有効なサービス", "d) テナンシに有効なサービス"], correct: "c", explanation: "正解: c) オブジェクト・ストレージは、特定の可用性ドメイン（AD）に属さず、<b>リージョン全体で有効なサービス</b>です。リージョン内のどのADからでも、またインターネット経由でもアクセスできます。" },
            { q: "オブジェクトストレージの3つの異なるストレージ層として正しいものはどれか。3つ選択してください。", options: ["a) 標準", "b) 頻度の低いアクセス", "c) アーカイブ", "d) オールド"], correct: ["a", "b", "c"], explanation: "正解: a), b), c)<br>OCIオブジェクト・ストレージには、アクセス頻度とコストに応じて3つのストレージ層があります。<br>・<b>標準 (Standard)</b>: 高速で即時アクセスが必要なデータ向け。<br>・<b>頻度の低いアクセス (Infrequent Access)</b>: 長期間保持するが、アクセス頻度が低いデータ向け。ストレージコストは安いが、データ取得コストがかかる。<br>・<b>アーカイブ (Archive)</b>: ほとんどアクセスされないデータの長期保管向け。最も安価だが、データ取得に数時間かかる。" },
            { q: "以下のような条件の場合、適切なストレージ層はどれか。\n31日以上、90日未満の期間、オブジェクトストレージでデータを保持したい。あまりアクセスはしないため、コストをできるだけ安くしたい。", options: ["a) 標準", "b) 頻度の低いアクセス", "c) アーカイブ", "d) オールド"], correct: "b", explanation: "正解: b) <b>頻度の低いアクセス層</b>は、最低31日間の保存が要件です。アクセス頻度は低いが、アーカイブ層のように取得に時間をかけたくないデータに適しており、標準層よりストレージコストを抑えられます。設問の要件に最も合致します。" },
            { q: "マルチパート・アップロードのオブジェクト・パートサイズ(分割サイズ)で選択できるものとして正しいものはどれか。", options: ["a) 10MiB~50GiB", "b) 10MiB~100MiB", "c) 100MiB~150MiB", "d) 500MiB~1000MiB"], correct: "a", explanation: "正解: a) マルチパート・アップロードは、大きなオブジェクトを小さな「パート」に分割してアップロードする機能です。各パートのサイズは<b>10MiBから50GiB</b>の間で指定する必要があります。" },
            { q: "マルチパートアップロードでOCI CLIを使用した場合、正しいものはどれか。2つ選択してください。", options: ["a) 事前にオブジェクトをパーツに分割する必要がない", "b) 事前にオブジェクトをパーツに分割する必要がある", "c) パーツサイズを指定して実行する", "d) パーツサイズは自動で調整される"], correct: ["a", "c"], explanation: "正解: a), c)<br>OCIのコマンドライン・インタフェース（CLI）を使用してマルチパート・アップロードを行う場合、CLIが自動的にファイルを分割、アップロード、再結合を行ってくれるため、<b>ユーザーが手動でファイルを分割する必要はありません</b>。ただし、`--part-size`オプションで<b>パートサイズを指定</b>することは推奨されています。" },
            { q: "オブジェクトストレージの自動階層化に関する説明として正しいものはどれか。", options: ["a) フォルダのカテゴリに合わせ、自動でフォルダを階層化する機能", "b) 格納してから31日間アクセスがないオブジェクトを自動的にアーカイブ層へ移動させる機能", "c) 格納してから31日間アクセスがないオブジェクトを自動的に頻度の低いアクセス層へ移動させる機能", "d) 一度自動的に移動されたオブジェクトは標準層に戻すことができない"], correct: "c", explanation: "正解: c) 自動階層化は、ライフサイクル・ポリシーの一種で、標準層のバケットで有効にできます。この機能を有効にすると、<b>オブジェクトへのアクセスが31日間ない場合、自動的にコストの安い「頻度の低いアクセス」層へ移動</b>します。オブジェクトに再度アクセスすると、自動で標準層に戻ります。" },
            { q: "オブジェクトストレージのライフサイクル管理に関する説明として正しいものはどれか。", options: ["a) オブジェクトを自動で移動、削除する設定を行う機能", "b) オブジェクトを移動、削除するための権限を管理する機能", "c) ライフサイクル管理は一度有効にすると無効にすることができない", "d) オブジェクトの中身をフィルタ対象にすることができる"], correct: "a", explanation: "正解: a) ライフサイクル管理は、オブジェクトの経過日数やバージョンに基づいて、<b>ストレージ層間での移動（例：標準→アーカイブ）やオブジェクトの削除を自動的に行う</b>ためのルールを定義する機能です。これにより、ストレージコストの最適化やデータ管理の自動化が可能になります。" },
            { q: "オブジェクトストレージのレプリケーションに関する説明として正しいものはどれか。", options: ["a) オブジェクトストレージのファイルを自動的にアーカイブして長期保存することができる", "b) オブジェクトストレージのデータを自動的に圧縮して保存コストを削減するができる", "c) オブジェクトストレージのアクセスログを自動的に分析してセキュリティレポートを生成することができる", "d) データを別リージョンや別バケットにコピーすることで冗長性が担保できる"], correct: "d", explanation: "正解: d) オブジェクト・ストレージのレプリケーションは、あるバケット内のオブジェクトを、<b>別のリージョンにある別のバケットへ継続的かつ非同期にコピー</b>する機能です。これにより、災害対策（DR）やデータ主権の要件に対応するためのデータの冗長性を確保できます。" },
            { q: "オブジェクトストレージのレプリケーションの制約として正しいものはどれか。3つ選択してください。", options: ["a) 送り先バケットを指定する必要があり、バケットが作成されていないとレプリケーションができない", "b) 各オブジェクトごとにレプリケーションの設定を行う必要がある(バケット内すべてのオブジェクトを一括コピー等は不可)", "c) レプリケーションが可能なオブジェクトは標準層のみである", "d) アーカイブストレージからオブジェクトをコピーすることができない"], correct: ["a", "b", "d"], explanation: "正解: a), b), d)<br>レプリケーションを設定するには、<b>コピー先となるバケットが事前に存在している必要があります</b>。" },
            { q: "オブジェクト・バージョンに関する説明として正しいものはどれか。", options: ["a) オブジェクトバージョンはデフォルトで有効になっている", "b) コンパートメント単位でバージョニング管理が可能である", "c) バケット単位でバージョニング管理が可能である"], correct: "c", explanation: "正解: c) オブジェクトのバージョニングは、<b>バケット単位で有効または無効</b>に設定する機能です。デフォルトでは無効になっています。有効にすると、オブジェクトの上書きや削除をしても、以前のバージョンが保持されるようになります。" },
            { q: "オブジェクトバージョニングが有効になった状態で、既存のオブジェクトと同一のファイルをアップロードした。そのオブジェクトのバージョニングとして正しいものはどれか。", options: ["a) 既存のファイルは削除され、新規アップロードファイルが新規ファイルとして格納される", "b) 既存ファイルに上書きされ、バージョンが更新される", "c) 既存のファイルおよび新規アップロードファイルのバージョンは同一で更新される", "d) 既存のファイルは古いバージョンとして残り、新規アップロードファイルとして新しいバージョンのファイルが格納される"], correct: "d", explanation: "正解: d) バージョニングが有効なバケットでは、同名のオブジェクトをアップロードすると、既存のオブジェクトは古いバージョンとして保持され、新しくアップロードされたものが最新バージョンとなります。これにより、誤った上書きからデータを保護できます。" },
            { q: "オブジェクトの保持ルールに関する説明として正しいものはどれか。2つ選択してください。", options: ["a) オブジェクトが一定期間バケットに存在できるよう、期間を指定する", "b) レプリケーション先のオブジェクトには保持ルールの適用ができない", "c) 一度書き込んだデータを変更することができないよう、ルールを設定することができる", "d) ルールは期限付きでのみ設定可能である"], correct: ["b", "c"], explanation: "正解: b), c)<br>保持ルール（Retention Rules）は、オブジェクトが<b>指定された期間、上書きまたは削除されるのを防ぐ</b>ための機能です（WORM: Write Once, Read Many）。ルールには、期間を指定する「期限付き（Time-bound）」と、解除されるまで永続する「無期限（Indefinite）」の2種類があります。" },
            { q: "オブジェクトのコピーに関する説明として正しいものはどれか。", options: ["a) 同一リージョンの同一バケットにコピーすることができる", "b) コピーされたオブジェクトは、コピー元のオブジェクトと同期している", "c) アーカイブストレージからは直接コピーができない", "d) コピー先のバケットはコピーの作成時に自動で作成される"], correct: "c", explanation: "正解: c) アーカイブ・ストレージ層にあるオブジェクトは、データがオフラインで保管されているため、コピーなどの操作を行う前に<b>一度標準ストレージ層にリストア（復元）する</b>必要があります。オブジェクトのコピーはコピー元とは独立した新しいオブジェクトを作成する操作であり、同期はされません。" },
            { q: "ロギングサービスでオブジェクトストレージの情報を収集する場合、どの組み合わせのイベントを収集することができるか。", options: ["a) create/delete/update", "b) read/write", "c) manage/read", "d) accept/reject"], correct: "b", explanation: "正解: b) オブジェクト・ストレージのアクセスログを有効にすると、オブジェクトの<b>読み取りイベント（Read）</b>と<b>書き込みイベント（Write）</b>に関するログが収集されます。これにより、誰がいつどのオブジェクトにアクセスしたかを追跡できます。" },
            { q: "事前認証済リクエストに関する説明として正しいものはどれか。2つ選択してください。", options: ["a) 事前に許可したIPアドレスでオブジェクトストレージにアクセスができるようにする機能", "b) ユーザーが認証情報を持たずにアクセスを行えるよう、固有のURLを発行しアクセスができるようにする機能", "c) 事前認証済リクエストを使用してアクセスしたオブジェクトに対して、読み取り/書き込みの操作はアクセスしたユーザーが指定できる", "d) 事前認証済リクエストの有効期限を設定せず利用することはできない"], correct: ["b", "d"], explanation: "正解: b), d)<br>事前認証済リクエスト（PAR）は、OCIの認証情報（ユーザー名/パスワード等）を持たないユーザーに対して、オブジェクトやバケットへのアクセスを許可するための<b>一時的なURL</b>を生成する機能です。セキュリティのため、<b>必ず有効期限を設定する必要があります</b>。" },
            { q: "Local NVMeのボリュームを使用することができるシェイプはどれか。2つ選択してください。", options: ["a) BM.DenseIO2.52", "b) VM.DenseIO2.8", "c) VM.Standard3.Flex", "d) BM.GPU3"], correct: ["a", "b"], explanation: "正解: a), b)<br>ローカルNVMe SSDは、物理サーバーに直接接続された非常に高速なストレージです。このストレージは、<b>DenseIO（高密度I/O）</b>と名付けられた特定のシェイプでのみ提供されます。これにはベアメタル（BM）と仮想マシン（VM）の両方が含まれます。" },
            { q: "ブロックボリュームの4つパフォーマンスとして正しい組み合わせはどれか。", options: ["a) ・より低いコスト　・バランス　・より高いパフォーマンス　・UHP(Ultra High Performance)", "b) ・より低いコスト　・スタンダード　・より高いパフォーマンス　・UHP(Ultra High Performance)", "c) ・より低いコスト　・スタンダード　・より高いパフォーマンス　・超高速", "d) ・より低いコスト　・バランス　・より高いパフォーマンス　・超高速"], correct: "a", explanation: "正解: a)<br>ブロック・ボリュームには、コストと性能の要件に応じて4つのパフォーマンス・レベルがあります。<br>・<b>より低いコスト</b>: バックアップなどスループット重視のワークロード向け。<br>・<b>バランス</b>: ほとんどのワークロードに適した標準的なレベル。<br>・<b>より高いパフォーマンス</b>: 高いI/O性能を必要とするデータベースなどに適している。<br>・<b>UHP (超高パフォーマンス)</b>: 最も要求の厳しいワークロード向けの最高レベル。" },
            { q: "ブロックボリュームのアクセスタイプとして選択可能なものはどれか。3つ選択してください。", options: ["a) 読み取り専用", "b) 読み取り専用　ー共有可能", "c) 読み取り/書き込み", "d) 読み取り/書き込み　ー共有可能"], correct: ["b", "c", "d"], explanation: "正解: b), c), d)<br>ブロック・ボリュームのアタッチ時にはアクセスタイプを選択します。「読み取り専用」という項目は用意されていません。" },
            { q: "ブロックボリュームのアタッチ/デタッチに関する説明として正しいものはどれか。", options: ["a) 一度デタッチ(インスタンスから切り離し)したボリュームはインスタンスに再アタッチできない", "b) 一度デタッチ(インスタンスから切り離し)したボリュームは別のインスタンスに再アタッチできないが、同一のインスタンスであれば再アタッチ可能", "c) 一度デタッチ(インスタンスから切り離し)したボリュームは同一及び別のインスタンスに再アタッチすることができる", "d) 一度デタッチ(インスタンスから切り離し)したボリュームは同一インスタンスに再アタッチできないが、別のインスタンスであれば再アタッチ可能"], correct: "c", explanation: "正解: c) ブロック・ボリュームは永続的なストレージであり、インスタンスのライフサイクルとは独立しています。インスタンスから<b>デタッチ（切り離し）した後、元のインスタンスや、同じ可用性ドメイン内の別のインスタンスに再アタッチ</b>することができます。" },
            { q: "共有ブロックボリュームに関する説明として正しいものはどれか。2つ選択してください。", options: ["a) 複数のインスタンスからの同時書き込みによるデータ破損を防止するための機能が備わっている", "b) 共有ブロックボリュームを使用する場合は、アクセスタイプをRead-Onlyにする必要がある", "c) 複数のインスタンスで同一のボリュームを使用することができる", "d) 1つの共有ボリュームには最大8つのインスタンスを接続することができる"], correct: ["c", "d"], explanation: "正解: c), d)<br>共有ブロック・ボリュームは、<b>複数のインスタンスから1つのボリュームを同時にアタッチ</b>できる機能です。クラスタ構成などで利用され、1つのボリュームに最大で<b>8つのインスタンス</b>を接続できます。ただし、データ破損を防ぐためのファイルシステムレベルでのロック管理は、ユーザー側（OSやアプリケーション）で実装する必要があります。" },
            { q: "ブート・ボリュームに関する説明として正しいものはどれか。", options: ["a) インスタンスを起動するときに使用する、OSが入ったブロックボリュームのことである", "b) 様々なアプリケーションが搭載されたブロックボリュームのことである", "c) データの読み書きが高速な領域として提供されているブロックボリュームのことである", "d) ブロックボリュームのバックアップとして提供されているブロックボリュームのことである"], correct: "a", explanation: "正解: a) ブート・ボリュームは、コンピュート・インスタンスの起動に必要な<b>オペレーティングシステム（OS）や関連ファイルを含む</b>、特殊なブロック・ボリュームです。インスタンスのルート・ディスクとして機能します。" },
            { q: "ブートボリュームのアタッチ/デタッチに関する説明として正しいものはどれか。", options: ["a) ブートボリュームはデタッチすることができない", "b) インスタンス起動中でもデタッチすることができる", "c) インスタンス停止中及び終了した場合のみデタッチすることができる", "d) インスタンスを終了した場合のみデタッチすることができる"], correct: "c", explanation: "正解: c) ブート・ボリュームはインスタンス稼働中にアタッチ、デタッチはできません。ブートボリュームは アタッチタイプが「起動専用」 なので、通常のデータボリュームのような自由な付け外しができないようになっています。" },
            { q: "動的パフォーマンス・スケーリングを使用して、以下の条件の設定を行いたい。適切な設定はどれか。できる限りコストを削減したい。ボリュームを使用していない期間はインスタンスからデタッチしている。", options: ["a) パフォーマンス・ベースの自動チューニング", "b) デタッチされたボリューム自動チューニング", "c) アタッチされたボリューム自動チューニング", "d) メトリック・ベースの自動チューニング"], correct: "b", explanation: "正解: b) <b>デタッチされたボリュームの自動チューニング</b>は、ブロック・ボリュームがどのインスタンスにもアタッチされていない場合に、パフォーマンスレベルを自動的に「より低いコスト」に引き下げる機能です。これにより、使用していないボリュームのコストを最小限に抑えることができます。" },
            { q: "ブロックボリューム/ブートボリュームのサイズ変更に関する説明として正しいものはどれか。", options: ["a) サイズの上限/下限なく、自由に変更ができる", "b) サイズの縮小は可能だが、拡大はできない", "c) サイズの拡大は可能だが、縮小はできない", "d) 構築した状態からサイズの変更はできない"], correct: "c", explanation: "正解: c) ブロック・ボリュームおよびブート・ボリュームは、インスタンスの稼働中に<b>オンラインでサイズを拡大</b>することができます。ただし、一度拡大したボリュームの<b>サイズを縮小することはできません</b>。" },
            { q: "ブロックボリュームのクローンしたボリュームのサイズ変更に関する説明として正しいものはどれか。", options: ["a) サイズの上限/下限なく、自由に変更ができる", "b) サイズの縮小は可能だが、拡大はできない", "c) サイズの拡大は可能だが、縮小はできない", "d) 構築した状態からサイズの変更はできない"], correct: "c", explanation: "正解: c) クローンも通常のブロック・ボリュームと同様に、作成後にサイズを<b>拡大することはできますが、縮小することはできません</b>。" },
            { q: "ボリュームサイズの変更を行う際の規約として正しいものはどれか。", options: ["a) インスタンスを停止し、ボリュームをデタッチすることでボリュームサイズの変更が可能である。サイズ変更後は既存インスタンス/新規インスタンスに再アタッチ可能", "b) インスタンスを終了し、自動でデタッチさせることでボリュームサイズの変更が可能である。サイズ変更後は新規インスタンスにのみ再アタッチ可能", "c) インスタンスが稼働中のままボリュームをデタッチさせることでボリュームサイズの変更が可能である。サイズ変更後は既存インスタンス/新規インスタンスに再アタッチ可能", "d) インスタンスからボリュームをデタッチせず、ボリュームサイズの変更が可能である"], correct: "d", explanation: "正解: d) OCIのブロック・ボリュームは、<b>インスタンスにアタッチされたまま、オンラインで</b>（つまりインスタンスを稼働させたまま）ボリュームサイズを拡大することができます。これにより、サービスを停止することなくストレージ容量を拡張できます。" },
            { q: "ボリュームのバックアップを行った場合、バックアップの保存先として正しいものはどれか。", options: ["a) ファイルストレージ", "b) 同一のブロックボリューム", "c) 別のブロックボリューム", "d) オブジェクトストレージ"], correct: "d", explanation: "正解: d) ブロック・ボリュームおよびブート・ボリュームのバックアップは、高い耐久性と信頼性を持つ<b>オブジェクト・ストレージ</b>に保存されます。これにより、元のボリュームやADに障害が発生してもデータを保護できます。" },
            { q: "ボリュームバックアップで選択可能なバックアップのタイプとして正しいものはどれか。2つ選択してください。", options: ["a) 完全バックアップ", "b) 増分バックアップ", "c) 差分バックアップ", "d) 永久増分バックアップ"], correct: ["a", "b"], explanation: "正解: a), b)<br>OCIのボリューム・バックアップには2つのタイプがあります。<br>・<b>完全バックアップ (Full)</b>: ボリュームの全データをコピーします。<br>・<b>増分バックアップ (Incremental)</b>: 前回のバックアップ以降に変更されたデータのみをコピーします。リストア時には、OCIが自動的に完全バックアップと増分バックアップを組み合わせて復元します。" },
            { q: "ボリュームのバックアップに関する説明として正しいものはどれか。", options: ["a) 手動バックアップのみ可能であり、バックアップが必要なタイミングでユーザ自身がバックアップを行う", "b) ポリシーベースのみ可能であり、定義に従い自動でバックアップを行う", "c) 手動バックアップ/ポリシーベースのバックアップが可能だが、ポリシーベースはスケジュールを指定できない。", "d) 手動バックアップ/ポリシーベースのバックアップが可能であり、用途に応じて選択が可能である"], correct: "d", explanation: "正解: d) ボリュームのバックアップは、必要な時に都度行う<b>手動バックアップ</b>と、スケジュール（毎日、毎週など）や頻度を定義して自動的に実行する<b>ポリシーベースのバックアップ</b>の両方が可能です。用途に応じて使い分けることができます。" },
            { q: "Oracle定義のバックアップポリシーを定義を使用し、以下条件でボリュームのバックアップを行いたい。正しいバックアップポリシーの種類はどれか。月次増分バックアップと毎年1月初旬の増分バックアップ", options: ["a) Bronze", "b) Silver", "c) Gold"], correct: "a", explanation: "正解: a) Oracleが提供する定義済みのバックアップポリシーのうち、<b>Bronze</b>は月次増分バックアップと年次完全バックアップの組み合わせです。設問の要件（月次と年次）を最低限満たすのはBronzeポリシーです。Silverは週次、Goldは日次のバックアップが追加されます。" },
            { q: "ボリュームのクローンに関する説明として正しいものはどれか。2つ選択してください。", options: ["a) 同一の可用性ドメイン内でのみ作成が可能である", "b) 同一及び別の可用性ドメイン内にも作成が可能である", "c) ボリュームがインスタンスにアタッチされていた場合、ボリュームのクローンは行えない", "d) ボリュームがインスタンスにアタッチされた状態とデタッチされた状態では、クローンの作成可能個数が異なる"], correct: ["a", "d"], explanation: "正解: a), d)<br>ブロックボリュームのクローンは、既存のブロックボリュームの完全かつ即時なコピーを、<b>同じリージョン内</b>の新しいボリュームとして作成する機能です。作成可能個数は<b>インスタンスへのアタッチ時は同時に１個</b>まで、<b>デタッチ時は同時に10個</b>までとなります。" },
            { q: "バックアップとクローンバックアップ格納先の記述として正しい組み合わせはどれか。", options: ["a) クローン：ブロックボリューム　バックアップ：オブジェクトストレージ", "b) クローン：オブジェクトストレージ　バックアップ：オブジェクトストレージ", "c) クローン：オブジェクトストレージ　バックアップ：ブロックボリューム", "d) クローン：ブロックボリューム　バックアップ：ブロックボリューム"], correct: "a", explanation: "正解: a)<br>・<b>クローン</b>は、すぐに利用可能な状態のボリュームとして、<b>ブロックボリューム</b>のインフラ上に作成されます。<br>・<b>バックアップ</b>は、長期保管と高耐久性を目的として、<b>オブジェクトストレージ</b>に保存されます。" },
            { q: "バックアップとクローンが使用可能な範囲の記述として正しい組み合わせはどれか。", options: ["a) クローン：可用性ドメイン　バックアップ：コンパートメント", "b) クローン：リージョン　バックアップ：可用性ドメイン", "c) クローン：可用性ドメイン　バックアップ：リージョン", "d) クローン：フォルトドメイン　バックアップ：リージョン"], correct: "c", explanation: "正解: c)<br>・<b>クローン</b>は、ソースボリュームと<b>同じ可用性ドメイン（AD）内</b>にしか作成できません。<br>・<b>バックアップ</b>はオブジェクトストレージに保存されるリージョナルなリソースであり、リージョン内のどのADからでもリストアできます。また、<b>別リージョンにコピー</b>することも可能です。" },
            { q: "既存のブロックボリュームからボリュームをコピーし、すぐに使用をしたい場合、バックアップ/クローンどちらが最適か。", options: ["a) バックアップ", "b) クローン"], correct: "b", explanation: "正解: b) <b>クローン</b>は、作成を指示すると即座に利用可能なボリュームとして作成されます。一方、バックアップからのリストアはデータのサイズに応じて時間がかかります。そのため、コピーをすぐに使いたい場合はクローンが最適です。" },
            { q: "ボリュームグループに関する説明として正しいものはどれか。2つ選択してください。", options: ["a) ブロックボリュームをまとめてグループとして定義したもの", "b) ブートボリュームをまとめてグループとして定義したもの", "c) ボリュームグループ単位でバックアップ/クローンの作成が可能である", "d) ボリュームグループ単位でバックアップの作成が可能である(クローンは作成不可)"], correct: ["a", "c"], explanation: "正解: a), c)<br>ボリューム・グループは、複数の<b>ブロック・ボリューム</b>を一つの論理的なグループとして管理する機能です。これにより、グループ内の全ボリュームの整合性が取れた状態で、一括して<b>バックアップやクローンを作成</b>することができます。" },
            { q: "ボリュームのレプリケーションで対応しているレプリケーション先はどれか。2つ選択してください。", options: ["a) サブスクライブされた別リージョン", "b) 同一リージョンの別インスタンス", "c) 同一リージョンの別可用性ドメイン", "d) 同一リージョンの別フォルトドメイン"], correct: ["a", "c"], explanation: "正解: a), c)<br>ブロック・ボリュームの非同期レプリケーションは、<b>同一リージョン内の別の可用性ドメイン（AD）</b>、または<b>別のリージョン</b>にレプリカ（複製）を作成する機能です。これにより、AD障害やリージョン障害に備えたDR構成を実現します。" },
            { q: "クロス可用性ドメイン・レプリケーションが有効になっているボリュームのサイズ変更に関する説明として正しいものはどれか。", options: ["a) レプリケーション元、先のどちらもサイズ変更を行うことができる", "b) レプリケーション元はサイズ変更可能だが、レプリケーション先は変更ができない", "c) レプリケーション先はサイズ変更可能だが、レプリケーション元は変更ができない", "d) レプリケーション元、先のどちらもサイズ変更を行うことができない"], correct: "d", explanation: "正解: d) <br>レプリケーションが有効な状態でオリジナルボリュームのサイズを変更しようとすると、<b>エラーになる</b>か、<b>操作が許可されません。</b>レプリケーションを切ればサイズ変更は可能ですが、その場合はボリュームレプリカは削除されます。" },
            { q: "ファイルストレージへのアクセスに関する説明として正しいものはどれか。", options: ["a) パブリックなアクセスが可能であり、インターネット経由でアクセスが可能である", "b) パブリック及びプライベートなアクセスが可能であり、利用者側で自由に使用することができる", "c) プライベートなアクセスのみ可能であり、OCI内VCNからのみアクセスができる", "d) プライベートなアクセスのみ可能であり、OCI内のVCNやオンプレミス(FastConnect/IPSecVPNを使用したプライベートネットワーク環境)からのアクセスができる"], correct: "d", explanation: "正解: d) ファイル・ストレージ・サービス（FSS）は、NFSプロトコルを使用するプライベートなストレージです。アクセスは、OCIの<b>VCN内のインスタンス</b>、またはFastConnectやIPSec VPNで接続された<b>オンプレミス環境</b>からのみ可能です。インターネット経由での直接アクセスはできません。" },
            { q: "マウントターゲットに関する説明として正しいものはどれか。", options: ["a) ファイルシステムへのアクセスを検知し、許可されたアクセスか判断するための機能である", "b) ファイルシステムへのアクセスを行う際に使用されるエンドポイントのことである", "c) ファイルシステム内のデータに対し、どのアクション(読み取りや書き込み等)を行うかを検知し、制御するための機能である", "d) ファイルストレージへのアクセスを可能にするためのルーティングのことである"], correct: "b", explanation: "正解: b) マウント・ターゲットは、VCN内の特定のサブネットに作成される<b>NFSエンドポイント</b>です。インスタンスは、このマウント・ターゲットのプライベートIPアドレスに対してNFSマウントを行うことで、ファイル・システムにアクセスします。" },
            { q: "ファイルシステムのエクスポートに関する説明として正しいものはどれか。", options: ["a) ファイルシステムへのアクセスを検知し、許可されたアクセスか判断するための機能である", "b) ファイルシステムへのアクセスを行う際に使用されるエンドポイントのことである", "c) 各マウントターゲットが、どのファイルシステムを使用することができるかを制御するものである", "d) 各マウントターゲットがファイルストレージへのアクセスを可能にするためのルーティングのことである"], correct: "c", explanation: "正解: c) エクスポートは、<b>マウント・ターゲット経由でのファイル・システムへのアクセスを制御</b>します。エクスポート・オプションを設定することで、特定のIPアドレス範囲からのアクセスのみを許可したり、読み取り専用にしたりといった細かいアクセス制御が可能です。" },
            { q: "インスタンスにマウントターゲットをマウントする際のコマンドとして正しいものはどれか。", options: ["a) # mount 10.0.0.0:/fss /mnt/fss", "b) # mount /fss /mnt/fss", "c) # mount 10.0.0.0"], correct: "a", explanation: "正解: a) Linuxインスタンスからファイル・システムをマウントする際の標準的なコマンドは `mount <マウントターゲットIP>:<エクスポートパス> <ローカルマウントポイント>` という形式です。選択肢 a はこの形式に従っています。" },
            { q: "ファイルストレージのスナップショットを作成した場合、作成したスナップショットはどのディレクトリに作成されるか", options: ["a) .snap", "b) copy", "c) snapshot", "d) .snapshot"], correct: "d", explanation: "正解: d) ファイル・システムのスナップショットを作成すると、ファイルシステムのルートディレクトリ配下に隠しディレクトリとして<b>`.snapshot`</b>が作成され、その中にスナップショットが格納されます。ユーザーはこのディレクトリにアクセスして、過去の時点のファイルを確認・リストアできます。" },
            { q: "ファイルストレージのクローンに関する説明として正しいものはどれか。", options: ["a) マウントターゲットからクローンを作成する", "b) エクスポートからクローンを作成する", "c) スナップショットからクローンを作成する", "d) ファイルストレージごとクローンを作成する"], correct: "c", explanation: "正解: c) ファイル・ストレージのクローンは、既存の<b>スナップショット</b>をソースとして作成されます。これにより、特定の過去の時点のファイル・システムの完全なコピーを、書き込み可能な新しいファイル・システムとして作成できます。" },
            { q: "ファイルシステムのレプリケーションで対応しているレプリケーション先はどれか。3つ選択してください。", options: ["a) リージョン内の同一ファイルシステム", "b) リージョン内の別ファイルシステム", "c) 別リージョンのファイルシステム", "d) 複数のリージョンのファイルシステム"], correct: ["b", "c", "d"], explanation: "正解: b), c), d)<br>ファイル・システムのレプリケーションは、ソースのファイルシステムを、<b>同一リージョン内の別のAD</b>にあるファイルシステム、または<b>別のリージョン</b>にあるファイルシステムに複製できます。複数のターゲットに同時に複製することも可能です。" },
            { q: "NFSエクスポートオプションに関する説明として正しいものはどれか。", options: ["a) エクスポートが各インスタンスからファイルシステムに対してのアクセス(読み取りや書き込み、特権ポートからの接続)を制御するもの", "b) ファイルシステムの作成、マウントターゲットの作成の権限を付与するもの", "c) ファイルシステム内のファイル自体の読み込み、書き込み権限の付与を行うもの", "d) インスタンスとマウントターゲットの接続をファイアウォール機能で制御するもの"], correct: "a", explanation: "正解: a) NFSエクスポート・オプションは、マウント・ターゲットにアクセスしてくるクライアント（インスタンス）のIPアドレスに基づいて、<b>NFSレベルでのアクセス権（読み取り専用、読み取り/書き込みなど）を制御</b>します。これにより、マウント・ターゲットにアクセスできるクライアントを制限できます。" }
        ];

        function shuffleAndRegenerate() {
            for (let i = questions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [questions[i], questions[j]] = [questions[j], questions[i]];
            }
            document.getElementById('quiz').innerHTML = '';
            document.getElementById('score').innerHTML = '';
            generateQuiz();
        }


        function generateQuiz() {
            const quiz = document.getElementById('quiz');
            quiz.innerHTML = '';
            const totalQuestions = questions.length;
            document.querySelector('p').textContent = `全${totalQuestions}問`;

            questions.forEach((q, index) => {
                const div = document.createElement('div');
                div.className = 'question';
                div.id = `q-container-${index}`;

                const header = document.createElement('div');
                header.className = 'question-header';
                header.innerHTML = `<strong>問 ${index + 1}. ${q.q}</strong>`;
                div.appendChild(header);

                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'question-options';
                q.options.forEach((opt, i) => {
                    const label = document.createElement('label');
                    const input = document.createElement('input');
                    const value = String.fromCharCode(97 + i);
                    input.type = q.correct instanceof Array ? 'checkbox' : 'radio';
                    input.name = `q${index}`;
                    input.value = value;
                    label.appendChild(input);
                    label.appendChild(document.createTextNode(' ' + opt));
                    label.setAttribute('data-value', value);
                    optionsDiv.appendChild(label);
                });
                div.appendChild(optionsDiv);

                const toggleBtn = document.createElement('button');
                toggleBtn.textContent = '解説の表示/非表示';
                toggleBtn.className = 'toggle-explanation-btn';
                div.appendChild(toggleBtn);

                const expl = document.createElement('div');
                expl.className = 'explanation';
                expl.innerHTML = `<strong>解答解説:</strong> ${q.explanation}`;
                div.appendChild(expl);

                toggleBtn.addEventListener('click', () => {
                    checkAnswer(index, false); // 採点前でもハイライト
                    expl.classList.toggle('visible');
                });

                quiz.appendChild(div);
            });
        }

        function checkAnswer(index, isGrading) {
            const qData = questions[index];
            const questionDiv = document.getElementById(`q-container-${index}`);

            const selectedInputs = Array.from(questionDiv.querySelectorAll(`input[name="q${index}"]:checked`));
            const selectedValues = selectedInputs.map(input => input.value);

            let isCorrect;
            const correctAnswers = Array.isArray(qData.correct) ? qData.correct : [qData.correct];

            if (Array.isArray(qData.correct)) {
                isCorrect = (selectedValues.length === qData.correct.length) &&
                    selectedValues.sort().every((val, idx) => val === [...qData.correct].sort()[idx]);
            } else {
                isCorrect = (selectedValues.length === 1 && selectedValues[0] === qData.correct);
            }

            // ハイライトをリセット
            questionDiv.querySelectorAll('.question-options label').forEach(label => {
                label.classList.remove('correct-choice', 'incorrect-choice');
            });

            // ユーザーの選択をハイライト
            selectedValues.forEach(selectedValue => {
                const label = questionDiv.querySelector(`label[data-value="${selectedValue}"]`);
                if (label) {
                    if (correctAnswers.includes(selectedValue)) {
                        label.classList.add('correct-choice');
                    } else {
                        label.classList.add('incorrect-choice');
                    }
                }
            });

            // ユーザーが間違えた場合、または常に正解を表示したい場合、正解をハイライト
            if (!isCorrect || isGrading) {
                correctAnswers.forEach(correctValue => {
                    const label = questionDiv.querySelector(`label[data-value="${correctValue}"]`);
                    if (label && !label.classList.contains('correct-choice')) {
                        label.classList.add('correct-choice');
                    }
                });
            }

            if (isGrading) {
                questionDiv.querySelector('.explanation').classList.add('visible');
            }

            return isCorrect;
        }

        function grade() {
            let correctCount = 0;
            const totalQuestions = questions.length;

            questions.forEach((qData, index) => {
                if (checkAnswer(index, true)) {
                    correctCount++;
                }
            });

            const correctRate = Math.round((correctCount / totalQuestions) * 100);

            const passMark = Math.ceil(totalQuestions * 0.65);
            const scoreEl = document.getElementById('score');
            scoreEl.innerHTML = `あなたのスコア: ${correctCount} / ${totalQuestions}問 正解 (${correctRate}%)`;

            if (correctCount === totalQuestions) {
                scoreEl.innerHTML += `<br><span class="result-pass">🎉 満点！素晴らしい！！</span>`;
            } else if (correctCount >= passMark) {
                scoreEl.innerHTML += `<br><span class="result-pass">🎉 合格圏内！おめでとう！！</span>`;
            } else {
                scoreEl.innerHTML += `<br><span class="result-fail">📘 ざーこ♡ざーこ♡</span>`;
            }
        }

        function showAllAnswers() {
            questions.forEach((qData, index) => {
                checkAnswer(index, true); // 正解を表示して解説も表示
            });
        }

        function clearAllHighlights() {
            document.querySelectorAll('.question-options label').forEach(label => {
                label.classList.remove('correct-choice', 'incorrect-choice');
            });
            document.querySelectorAll('.explanation').forEach(el => {
                el.classList.remove('visible');
            });
            document.getElementById('score').innerHTML = '';
        }

        // Initial generation of the quiz
        generateQuiz();
    </script>

</body>

</html>
